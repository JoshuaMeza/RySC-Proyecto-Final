<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="authors" content="Joshua Meza, Jonathan Gomez, Ricardo Grimaldo">
    <title>Features</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="/dist/css/programming_with_sockets.css">
    <link rel="shortcut icon" href="/dist/img/favicon.ico?" type="image/vnd.microsoft.icon">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="/dist/index.html">RySC</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarContent" aria-controls="navbarContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarContent">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/dist/index.html">Inicio</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <main class="container shadow" style="text-align: justify;">
        <h1 class="text-center"><a href="../programming_with_sockets.html">Programación de aplicaciones con sockets</a></h1>
        <br>
        <h4>Características de los sockets</h4>
        <p>
            Un socket, desde el punto de vista funcional, se define como un punto
            terminal al que pueden “enchufarse” dos procesos para comunicar entre sí.
            Para que dos procesos pudieran comunicar hubo que dotar al sistema de una
            serie de funciones que permitieran a esos procesos acceder a los dispositivos
            de red. Cuando se consideró cómo añadir funciones al sistema operativo para
            suministrar acceso a las comunicaciones, surgieron dos posibilidades:
        </p>
        <img class="mx-auto d-block" style="max-width: 35%; float: right; padding: 2% 0 1% 1%" src="/dist/img/sockets.png" alt="Card image cap">
        <ul>
            <li>Definir funciones que soportaran específicamente el protocolo TCP/IP.</li>
            <li>Definir funciones que soportaran cualquier tipo de protocolo de comunicaciones y parametrizarlas cuando se quisiera utilizar TCP/IP.</li>
        </ul>
        <p>En el momento del desarrollo del interfaz, el protocolo TCP/IP no estaba
            tan ampliamente divulgado como ahora y existían otras posibilidades para
            establecer comunicaciones entre dos máquinas. Por esta razón, los diseñadores optaron por la segunda opción: mantener la generalidad del interfaz.
            Al desvincular el interfaz de sockets de un protocolo de comunicaciones
            determinado, se hará necesario especificar ese protocolo cuando se usen esas
            funciones. De esta manera, cada vez que se quiera utilizar el interfaz de
            sockets, será necesario especificar:            
        </p>
        <img class="mx-auto d-block" style="max-width: 40%; float: left; padding: 0 4% 1% 2%" src="/dist/img/sockets_4.png" alt="Card image cap">
        <ul>
            <li><strong>Familia de protocolo: </strong>Hay que indicar qué tipo de protocolo se va a utilizar para realizar las distintas comunicaciones. Los protocolos TCP/IP constituyen una única familia representada por la constante PF_INET. En el caso de comunicaciones entre procesos en la misma máquina usando el sistema de ficheros, tendríamos la familia de protocolos identificada como PF_UNIX.</li>
            <li><strong>Tipo de servicio: </strong>El interfaz permite seleccionar el tipo de servicio que se desea siempre y cuando el protocolo seleccionado sea capaz de suministrar distintos tipos de servicio. Aquí por tipo de servicio nos estamos refiriendo a cosas como comunicación orientada a la conexión o bien a comunicación orientada a los datagramas.</li>
            <li><strong>Familia de direcciones finales: </strong>Cada familia de protocolos especifica la dirección final de una comunicación de una manera distinta. La dirección final de una comunicación es el “punto” a través del cual un proceso envía o recibe datos. Por ejemplo, en IP, una dirección final se especifica usando la dirección IP de la máquina y el número de puerto de protocolo que usará el programa. En el caso de usar la familia de protocolos UNIX la dirección final será el nombre de un fichero. El interfaz permite que las direcciones finales se puedan expresar con distintos formatos aún dentro de la propia familia de protocolos. Cada una de esas posibles representaciones correspondería a una familia de direcciones.</li>
        </ul>
    </main>

    <script src="https://kit.fontawesome.com/a2e2b9d23e.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        crossorigin="anonymous"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
    <script src="../js/template.js"></script>
</body>
</html>
