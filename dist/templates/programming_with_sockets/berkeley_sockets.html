<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="authors" content="Joshua Meza, Jonathan Gomez, Ricardo Grimaldo">
    <title>Barkeley Sockets</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="/dist/css/programming_with_sockets.css">
    <link rel="shortcut icon" href="/dist/img/favicon.ico?" type="image/vnd.microsoft.icon">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="/dist/index.html">RySC</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarContent" aria-controls="navbarContent" aria-expanded="false"
                aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarContent">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/dist/index.html">Inicio</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <main class="container shadow" style="text-align: justify;">
        <h1 class="text-center"><a href="../programming_with_sockets.html">Programación de aplicaciones con sockets</a></h1>
        <br>
        <h4>BERKELEY SOCKETS</h4>
        <p>
            El subsistema de entrada/salida de Unix, en general, sigue el paradigma denominado abrir – leer – escribir – cerrar. Sin embargo, el manejo de entrada/salida de red involucra más detalles y opciones. Por ejemplo, entre los aspectos a considerar se encuentran:
        </p>
        <img class="mx-auto d-block" style="max-width: 29%; float: left; padding: 1% 3% 0 0" src="/dist/img/sockets_2.png" alt="Card image cap">
        <ul>
            <li>La relación cliente/servidor es asimétrica. La aplicación requiere saber
                cuál será su rol (cliente o servidor) antes de inciar la comunicación.</li>
            <li>La entrada/salida de red puede trabajar orientada a conexión o sin
                conexión.</li>
            <li>
                En un entorno de red los nombres son más importantes que en el
                manejo de archivos o dispositivos.                
            </li>
            <li>Para especificar una conexión de red se requieren más parámetros que
                para abrir un archivo o dispositivo:
                {protocolo, dirección_local, proceso_local,
                 dirección_remota, proceso_remoto }</li>
            <li>La interfaz de red debe soportar múltiples protocolos.</li>
        </ul>
        <p>La adición de protocolos de red a UNIX incrementó sustancialmente la
            complejidad de la interfaz de E/S, pues los diseñadores intentaron construir un
            mecanismo general para incluir otros protocolos diferentes a TCP/IP. Como
            consecuencia, la aplicación no puede proporcionar una dirección de 32 bits y
            esperar a que el sistema operativo la interprete de manera correcta. La
            aplicación debe especificar explícitamente que el número de 32 bits representa
            una dirección IP.
        </p>
        <img class="mx-auto d-block" style="max-width: 30%; float: right; padding: 0 0 2% 2%" src="/dist/img/sockets_3.png" alt="Card image cap">
        <p>
            El subsistema de E/S de red de UNIX, principalmente se centra en una
            abstracción conocida como sócalo (socket). Pensamos al socket como una
            generalización del mecanismo de acceso a archivos de UNIX que proporciona
            un punto final para la comunicación. Similar al acceso a archivos, los
            programas de aplicación requieren que el sistema operativo cree un socket
            cuando se necesita. El sistema devuelve un short integer que utiliza el
            programa de aplicación para hacer referencia al socket creado. La diferencia
            principal entre los descriptores de archivos y los descriptores de sockets es que
            el sistema operativo enlaza un descriptor de archivo a un archivo o dispositivo
            específico cuando se llama a open, pero se pueden crear sockets sin
            enlazarlos a direcciones de destino específicas. La aplicación puede elegir
            especificar una dirección de destino cada vez que utiliza el socket (es decir,
            cuando se envían datagramas empleando UDP) o elegir enlazar la dirección
            destino a un socket y evadir su especificación repetidamente (es decir, cuando
            se hace una conexión TCP).  
        </p>
    </main>

    <script src="https://kit.fontawesome.com/a2e2b9d23e.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        crossorigin="anonymous"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
    <script src="../js/template.js"></script>
</body>
</html>
